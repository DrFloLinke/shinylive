[{"name":"app.R","content":"# app.R — Correlation Explorer (ShinyLive-ready, no \"moat\")\n# Changes in this version: removed the summary card entirely (no Kendall/Spearman/Pearson panel)\n\n# Ensure ggplot2 deps are present in WebR/ShinyLive\nif (requireNamespace(\"webr\", quietly = TRUE)) {\n  need <- c(\n    \"ggplot2\",\"MASS\",\"bslib\",\"thematic\",\n    \"munsell\",\"scales\",\"colorspace\",\"farver\",\"labeling\",\n    \"isoband\",\"gtable\",\"R6\",\"rlang\",\"withr\"\n  )\n  miss <- setdiff(need, rownames(installed.packages()))\n  if (length(miss)) webr::install(miss)\n}\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(bslib)\n\n# --- Tokens ---------------------------------------------------------------\nLIGHT_BLUE <- \"#767da2\"  # inputs + borders\nORANGE     <- \"#cd6118\"  # brand / primary\nFG         <- \"#e1e2ea\"  # text on dark\nAXIS       <- \"#adbdd1\"\n\n# --- Theme + CSS ----------------------------------------------------------\ndark_theme <- bs_theme(\n  version   = 5,\n  bg        = \"#1d1f2b\",\n  fg        = FG,\n  primary   = ORANGE,\n  secondary = \"#5a5f80\"\n) |>\n  bs_add_rules(\"\n    :root{\n      --bs-body-font-family: 'Lexend', system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial, sans-serif;\n      --bs-font-monospace: 'Recursive', ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace;\n    }\n\n    .container-fluid { max-width: 1100px; }\n    .shiny-input-container { margin-bottom: 10px; }\n\n    .container-fluid{\n      padding-top: 16px;\n      padding-top: calc(16px + env(safe-area-inset-top));\n      padding-bottom: 18px;\n      padding-bottom: calc(18px + env(safe-area-inset-bottom));\n    }\n\n    .no-stack { display: flex; gap: 16px; align-items: flex-start; }\n    .no-stack .left  { flex: 0 0 340px; min-width: 260px; }\n    .no-stack .right { flex: 1 1 auto; min-width: 0; }\n    @media (max-width: 576px) {\n      .no-stack { flex-direction: column; gap: 12px; }\n      .no-stack .left, .no-stack .right { flex: 1 1 100%; min-width: 0; }\n      .container-fluid { padding-left: 12px; padding-right: 12px; }\n    }\n\n    h2.title { font-size: 20px; line-height: 1.25; margin: 6px 0 10px; font-weight: 600; }\n    @media (max-width: 576px) { h2.title { font-size: 18px; } }\n\n    #plotBox{\n      background: var(--bs-body-bg) !important;\n      border: 1.5px solid #767da2 !important;\n      padding: 12px;\n      border-radius: .6rem;\n      box-shadow: none;\n      margin-top: 8px;\n      padding-bottom: 12px;\n    }\n\n    .form-control, .form-select, .selectize-input{\n      background-color: #767da2 !important;\n      color: var(--bs-body-color) !important;\n      border: 1px solid #767da2 !important;\n      box-shadow: none !important;\n    }\n    .form-control:focus, .form-select:focus, .selectize-input.focus{\n      border-color: #cd6118 !important;\n      outline: 0 !important;\n      box-shadow: 0 0 0 .15rem rgba(205,97,24,.35) !important;\n    }\n    .selectize-dropdown{\n      background: #2b2f49 !important;\n      color: var(--bs-body-color) !important;\n      border-color: #5a5f80 !important;\n    }\n    .selectize-dropdown .active, .selectize-dropdown .option:hover{\n      background: #5a5f80 !important; color: #ffffff !important;\n    }\n\n    #scatter img, #heatmap img { display:block; width:100%; height:auto !important; }\n  \")\n\n# --- Helpers --------------------------------------------------------------\nextend_lr <- function(x, f = 0.04) {\n  r <- range(x, na.rm = TRUE); d <- diff(r); c(r[1] - f*d, r[2] + f*d)\n}\n\n# Generate data: linear via correlated normals; non-linear via functions\ngen_data <- function(mode, n, r, pattern, noise, seed) {\n  set.seed(seed)\n  if (mode == \"continuous\") {\n    if (pattern == \"Linear (bivariate normal)\") {\n      x <- rnorm(n)\n      z <- rnorm(n)\n      y <- r * x + sqrt(pmax(0, 1 - r^2)) * z\n      data.frame(x, y)\n    } else if (pattern == \"Cubic\") {\n      x <- rnorm(n); y <- x^3 + rnorm(n, sd = noise); data.frame(x, y)\n    } else if (pattern == \"Quadratic\") {\n      x <- rnorm(n); y <- (x^2) + rnorm(n, sd = noise); y <- y - mean(y); data.frame(x, y)\n    } else data.frame(x = numeric(0), y = numeric(0))\n  } else NULL\n}\n\nsafe_cor <- function(x, y, method) {\n  out <- suppressWarnings(try(cor.test(x, y, method = method), silent = TRUE))\n  if (inherits(out, \"try-error\")) return(list(estimate = NA_real_, p = NA_real_))\n  list(estimate = unname(out$estimate), p = out$p.value)\n}\n\nphi_coef <- function(a, b, c, d) {\n  den <- sqrt((a+b)*(c+d)*(a+c)*(b+d)); if (den == 0) return(NA_real_)\n  (a*d - b*c) / den\n}\n\n# Dark ggplot theme (no grid lines; slightly smaller text)\ngg_dark <- theme(\n  text = element_text(colour = FG),\n  axis.title = element_text(size = 16, face = \"bold\", colour = FG),\n  axis.text  = element_text(size = 12, colour = FG),\n  axis.ticks = element_line(colour = AXIS),\n  axis.line  = element_line(colour = AXIS),\n  plot.title = element_text(size = 18, face = \"bold\", colour = FG),\n  panel.background = element_rect(fill = \"transparent\", colour = NA),\n  plot.background  = element_rect(fill = \"transparent\", colour = NA),\n  panel.grid.minor = element_blank(),\n  panel.grid.major = element_blank()\n)\n\n# --- UI -------------------------------------------------------------------\nui <- fluidPage(\n  theme = dark_theme,\n  tags$head(\n    tags$link(rel = \"preconnect\", href = \"https://fonts.googleapis.com\"),\n    tags$link(rel = \"preconnect\", href = \"https://fonts.gstatic.com\", crossorigin = \"anonymous\"),\n    tags$link(\n      href = \"https://fonts.googleapis.com/css2?family=Lexend:wght@300;400;500&family=Recursive:wght,MONO@400,1&display=swap\",\n      rel  = \"stylesheet\"\n    ),\n    tags$script(src = \"https://cdn.jsdelivr.net/npm/iframe-resizer/js/iframeResizer.contentWindow.min.js\"),\n    tags$script(HTML(\"\n      document.addEventListener('shiny:idle', function(){\n        if (window.parentIFrame && window.parentIFrame.size) window.parentIFrame.size();\n      });\n    \")),\n    # No-moat helpers\n    tags$script(HTML(\"\n      (function () {\n        function send() {\n          if (!window.Shiny) return;\n          Shiny.setInputValue('vh_px', window.innerHeight, {priority:'event'});\n          Shiny.setInputValue('resizeTick', Date.now(),     {priority:'event'});\n        }\n        window.addEventListener('load', send, {once:true});\n        document.addEventListener('shiny:connected', send);\n        window.addEventListener('resize', send);\n        window.addEventListener('orientationchange', send);\n      })();\n    \")),\n    tags$script(HTML(\"\n      Shiny.addCustomMessageHandler('setScatterH', function(px){\n        var el = document.getElementById('scatter');\n        if (el) el.style.height = String(px) + 'px';\n      });\n      Shiny.addCustomMessageHandler('setHeatH', function(px){\n        var el = document.getElementById('heatmap');\n        if (el) el.style.height = String(px) + 'px';\n      });\n    \"))\n  ),\n  \n  div(\n    class = \"no-stack\",\n    # LEFT\n    div(\n      class = \"left\",\n      h2(class = \"title\", \"Correlation Explorer\"),\n      radioButtons(\n        \"mode\", \"Data type\",\n        choices = c(\"Continuous (scatter)\" = \"continuous\", \"Binary (2×2, phi)\" = \"binary\"),\n        selected = \"continuous\"\n      ),\n      \n      conditionalPanel(\n        condition = \"input.mode == 'continuous'\",\n        selectInput(\n          \"pattern\", \"Relationship pattern\",\n          choices = c(\n            \"Linear (bivariate normal)\",\n            \"Quadratic\",\n            \"Cubic\"\n          ),\n          selected = \"Linear (bivariate normal)\", selectize = FALSE\n        ),\n        conditionalPanel(\n          condition = \"input.pattern == 'Linear (bivariate normal)'\",\n          sliderInput(\"r_target\", \"Target Pearson r\", min = -0.99, max = 0.99, value = 0.6, step = 0.01)\n        ),\n        conditionalPanel(\n          condition = \"input.pattern != 'Linear (bivariate normal)'\",\n          sliderInput(\"noise\", \"Noise (SD of added noise)\", min = 0, max = 1.5, value = 0.25, step = 0.05)\n        ),\n        sliderInput(\"n\", \"Sample size (n)\", min = 20, max = 500, value = 200, step = 5),\n        numericInput(\"seed\", \"Seed (for reproducibility)\", value = 122, step = 1),\n        checkboxInput(\"show_lm\", \"Show least-squares line\", value = TRUE),\n        checkboxInput(\"show_loess\", \"Show smooth (LOESS)\", value = TRUE),\n        tags$details(\n          tags$summary(\"What to look for\"),\n          tags$ul(\n            tags$li(\"Pearson r captures linear, directional association.\"),\n            tags$li(\"Spearman rho is rank-based; it can reveal monotonic but non-linear association.\"),\n            tags$li(\"Some strong non-linear patterns (e.g., Quadratic) can have r \\u2248 0.\")\n          )\n        )\n      ),\n      \n      conditionalPanel(\n        condition = \"input.mode == 'binary'\",\n        numericInput(\"a\", \"Cell a (1,1)\", value = 30, min = 0, step = 1),\n        numericInput(\"b\", \"Cell b (1,0)\", value = 10, min = 0, step = 1),\n        numericInput(\"c\", \"Cell c (0,1)\", value = 10, min = 0, step = 1),\n        numericInput(\"d\", \"Cell d (0,0)\", value = 30, min = 0, step = 1),\n        tags$details(\n          tags$summary(\"Phi coefficient\"),\n          tags$ul(\n            tags$li(\"Phi is Pearson's correlation applied to two binary variables.\"),\n            tags$li(\"It relates to the chi-square test of independence.\")\n          )\n        )\n      )\n    ),\n    \n    # RIGHT\n    div(\n      class = \"right\",\n      div(\n        id = \"plotBox\",\n        conditionalPanel(condition = \"input.mode == 'continuous'\", plotOutput(\"scatter\")),\n        conditionalPanel(condition = \"input.mode == 'binary'\",     plotOutput(\"heatmap\"))\n      ),\n      conditionalPanel(condition = \"input.mode == 'binary'\", div(id = \"bin_table\", tableOutput(\"contingency_table\")))\n    )\n  )\n)\n\n# --- Server ---------------------------------------------------------------\nserver <- function(input, output, session) {\n  \n  # ----- dynamic heights (no-moat) -----\n  scatterHeight <- reactive({\n    w <- session$clientData$output_scatter_width\n    if (is.null(w) || !is.finite(w) || w <= 0) w <- 600\n    compact  <- (w < 520)\n    h_from_w <- if (compact) max(260, 0.56 * w) else max(300, min(560, 0.62 * w))\n    vh <- input$vh_px\n    if (is.numeric(vh) && is.finite(vh) && vh > 0) {\n      cap <- if (compact) 0.58 * vh else 0.66 * vh\n      h_from_w <- min(h_from_w, cap)\n    }\n    round(h_from_w)\n  })\n  heatHeight <- reactive({\n    w <- session$clientData$output_heatmap_width\n    if (is.null(w) || !is.finite(w) || w <= 0) w <- 520\n    compact  <- (w < 520)\n    h_from_w <- if (compact) max(240, 0.50 * w) else max(280, min(520, 0.56 * w))\n    vh <- input$vh_px\n    if (is.numeric(vh) && is.finite(vh) && vh > 0) {\n      cap <- if (compact) 0.54 * vh else 0.62 * vh\n      h_from_w <- min(h_from_w, cap)\n    }\n    round(h_from_w)\n  })\n  observeEvent(list(scatterHeight(), input$resizeTick), {\n    session$sendCustomMessage(\"setScatterH\", scatterHeight())\n  }, ignoreInit = FALSE)\n  observeEvent(list(heatHeight(), input$resizeTick), {\n    session$sendCustomMessage(\"setHeatH\", heatHeight())\n  }, ignoreInit = FALSE)\n  \n  # ----------------------------- CONTINUOUS -------------------------------\n  dat_cont <- reactive({\n    req(input$mode == \"continuous\")\n    n     <- as.integer(input$n)\n    seed  <- as.integer(input$seed)\n    patt  <- input$pattern\n    r     <- if (!is.null(input$r_target)) as.numeric(input$r_target) else 0\n    noise <- if (!is.null(input$noise)) as.numeric(input$noise) else 0.25\n    gen_data(\"continuous\", n, r, patt, noise, seed)\n  })\n  \n  # keep for Pearson annotation on scatter\n  cont_stats <- reactive({\n    df <- dat_cont()\n    if (!nrow(df)) return(NULL)\n    list(\n      pear  = safe_cor(df$x, df$y, method = \"pearson\"),\n      spear = safe_cor(df$x, df$y, method = \"spearman\"),\n      kend  = safe_cor(df$x, df$y, method = \"kendall\")\n    )\n  })\n  \n  output$scatter <- renderPlot({\n    df <- dat_cont()\n    validate(need(nrow(df) > 1, \"Not enough data to plot.\"))\n    xr <- extend_lr(df$x); yr <- extend_lr(df$y)\n    \n    p <- ggplot(df, aes(x, y)) +\n      geom_point(alpha = 0.9, size = 2.2, shape = 16, colour = FG) +\n      coord_cartesian(xlim = xr, ylim = yr) +\n      labs(x = \"X\", y = \"Y\", title = input$pattern) +\n      gg_dark\n    \n    if (isTRUE(input$show_lm)) {\n      p <- p + geom_smooth(method = \"lm\", se = FALSE, size = 1.0, colour = ORANGE)\n    }\n    if (isTRUE(input$show_loess)) {\n      p <- p + geom_smooth(method = \"loess\", se = FALSE, size = 1.0, linetype = \"longdash\", colour = LIGHT_BLUE)\n    }\n    \n    st <- cont_stats()\n    if (!is.null(st) && is.finite(st$pear$estimate)) {\n      p <- p + annotate(\n        \"label\",\n        x = xr[1] + 0.02 * diff(xr),\n        y = yr[2] - 0.03 * diff(yr),\n        hjust = 0, vjust = 1,\n        label = sprintf(\"Pearson r = %.3f\", st$pear$estimate),\n        size = 4.2, label.size = 0, fill = NA, colour = FG\n      )\n    }\n    p\n  },\n  width = function() {\n    w <- session$clientData$output_scatter_width\n    if (is.null(w) || !is.finite(w) || w <= 0) w <- 600\n    round(max(320, min(1100, w)))\n  },\n  height = function() scatterHeight(),\n  res = 96, execOnResize = TRUE, bg = \"transparent\")\n  \n  # ------------------------------- BINARY ---------------------------------\n  bin_counts <- reactive({\n    req(input$mode == \"binary\")\n    a <- as.integer(input$a); b <- as.integer(input$b)\n    c <- as.integer(input$c); d <- as.integer(input$d)\n    if (any(!is.finite(c(a,b,c,d)))) return(NULL)\n    list(a = a, b = b, c = c, d = d)\n  })\n  \n  bin_stats <- reactive({\n    bc <- bin_counts(); if (is.null(bc)) return(NULL)\n    mat <- matrix(c(bc$a, bc$b, bc$c, bc$d), nrow = 2, byrow = TRUE)\n    dimnames(mat) <- list(Row = c(\"1\", \"0\"), Col = c(\"1\", \"0\"))\n    chisq <- suppressWarnings(try(chisq.test(mat, correct = FALSE), silent = TRUE))\n    phi   <- phi_coef(bc$a, bc$b, bc$c, bc$d)\n    list(\n      mat = mat, phi = phi,\n      chi2 = if (!inherits(chisq, \"try-error\")) chisq$statistic else NA_real_,\n      df   = if (!inherits(chisq, \"try-error\")) chisq$parameter else NA_real_,\n      p    = if (!inherits(chisq, \"try-error\")) chisq$p.value   else NA_real_\n    )\n  })\n  \n  output$heatmap <- renderPlot({\n    st <- bin_stats(); validate(need(!is.null(st), \"Enter cell counts.\"))\n    df <- as.data.frame(as.table(st$mat)); names(df) <- c(\"Row\", \"Col\", \"Count\"); df$Prop <- df$Count / sum(df$Count)\n    \n    ggplot(df, aes(Col, Row, fill = Prop)) +\n      geom_tile(size = 1, colour = LIGHT_BLUE) +\n      geom_text(aes(label = Count), size = 6, colour = FG) +\n      scale_y_discrete(limits = rev) +\n      scale_fill_gradient(low = \"#2b2f49\", high = FG, guide = \"none\") +\n      labs(x = \"Column\", y = \"Row\", title = \"2×2 table (counts)\") +\n      gg_dark\n  },\n  width = function() {\n    w <- session$clientData$output_heatmap_width\n    if (is.null(w) || !is.finite(w) || w <= 0) w <- 520\n    round(max(320, min(1100, w)))\n  },\n  height = function() heatHeight(),\n  res = 96, execOnResize = TRUE, bg = \"transparent\")\n  \n  output$contingency_table <- renderTable({\n    st <- bin_stats(); if (is.null(st)) return(NULL)\n    addmargins(st$mat)\n  }, bordered = TRUE, striped = FALSE, spacing = \"xs\")\n}\n\nshinyApp(ui, server)\n","type":"text"}]
